(ql:quickload 'iterate)
(ql:quickload 'series)
(ql:quickload 'cl-ppcre)
(require :queues.simple-queue)
(require 'iterate)
(defpackage :advent21-22 (:use :cl :uiop :iterate))
(in-package :advent21-22)

(defun flatten (lst)
  (labels ((rflatten (lst1 acc)
             (dolist (el lst1)
               (if (listp el)
                   (setf acc (rflatten el acc))
                   (push el acc)))
             acc))
    (reverse (rflatten lst nil))))

(defclass cuboid ()
  (
   (power :accessor cuboid-power)
   (x1 :accessor cuboid-x1)
   (x2 :accessor cuboid-x2)
   (y1 :accessor cuboid-y1)
   (y2 :accessor cuboid-y2)
   (z1 :accessor cuboid-z1)
   (z2 :accessor cuboid-z2)
   ))

(defun make-cuboid ()
  (make-instance 'cuboid))

(defun make-cuboid-full (x1 x2 y1 y2 z1 z2 &optional ps)
  (let ((c (make-instance 'cuboid)))
    (setf (cuboid-power c) ps)
    (setf (cuboid-x1 c) x1)
    (setf (cuboid-x2 c) x2)
    (setf (cuboid-y1 c) y1)
    (setf (cuboid-y2 c) y2)
    (setf (cuboid-z1 c) z1)
    (setf (cuboid-z2 c) z2)
    c))

(defun copy-cuboid (c)
  (let ((nc (make-cuboid-full (cuboid-x1 c) (cuboid-x2 c) (cuboid-y1 c) (cuboid-y2 c) (cuboid-z1 c) (cuboid-z2 c))))
    (setf (cuboid-power nc) (cuboid-power c))
    nc))

(defun set-cuboid-dim (c1 dim v1 v2)
  (if (string= dim "x")
      (progn
        (setf (cuboid-x1 c1) (min v1 v2))
        (setf (cuboid-x2 c1) (max v1 v2)))
      (if (string= dim "y")
          (progn
            (setf (cuboid-y1 c1) (min v1 v2))
            (setf (cuboid-y2 c1) (max v1 v2)))
          (if (string= dim "z")
              (progn
                (setf (cuboid-z1 c1) (min v1 v2))
                (setf (cuboid-z2 c1) (max v1 v2)))))))


(defun make-cuboid-from-line (line)
  (let ((temp 'nil)
        (t2 'nil)
        (t3 'nil)
        (c1 (make-cuboid))
        (v1 'nil)
        (v2 'nil)
        (dim 'nil))

    (setf temp (cl-ppcre:split " " line))
    (setf (cuboid-power c1) (string= (car temp) "on"))
    (setf temp (cadr temp))
    (setf temp (cl-ppcre:split ","  temp))

    (setf t2   (cl-ppcre:split "="  (car temp)))
    (setf dim (car t2))
    (setf t3    (cl-ppcre:split "\\.\\."  (cadr t2)))
    (setf v1 (parse-integer (car t3)))
    (setf v2 (parse-integer (cadr t3)))
    (set-cuboid-dim c1 dim v1 v2)
    ;(format t "xstart ~d xstop ~d~%" xstart xstop)

    (setf t2   (cl-ppcre:split "="  (cadr temp)))
    (setf dim (car t2))
    (setf t3    (cl-ppcre:split "\\.\\."  (cadr t2)))
    (setf v1 (parse-integer (car t3)))
    (setf v2 (parse-integer (cadr t3)))
    (set-cuboid-dim c1 dim v1 v2)    
    ;(format t "ystart ~d ystop ~d~%" ystart ystop)
    
    (setf t2   (cl-ppcre:split "="  (caddr temp)))
    (setf dim (car t2))
    (setf t3    (cl-ppcre:split "\\.\\."  (cadr t2)))
    (setf v1 (parse-integer (car t3)))
    (setf v2 (parse-integer (cadr t3)))
    (set-cuboid-dim c1 dim v1 v2)        
    ;(format t "zstart ~d zstop ~d~%" zstart zstop)
    c1 ))

(defmethod print-object ((obj cuboid) stream)
      (print-unreadable-object (obj stream :type t)
        (with-accessors ((power cuboid-power)
                         (x1 cuboid-x1)
                         (x2 cuboid-x2)
                         (y1 cuboid-y1)
                         (y2 cuboid-y2)
                         (z1 cuboid-z1)
                         (z2 cuboid-z2)
                         )
            obj
          (format stream "power: ~a x1: ~d x2: ~d y1: ~d y2: ~d z1: ~d z2: ~d " power x1 x2 y1 y2 z1 z2))))

(defun read-input (filename)
  (mapcar #'make-cuboid-from-line (uiop:read-file-lines filename)))

(defmethod point-in-cuboid-p ((c cuboid) point)
  (let ((px (car point))
        (py (cadr point))
        (pz (caddr point)))
    (if (and (>= px (cuboid-x1 c)) (<= px (cuboid-x2 c)))
        (if (and (>= py (cuboid-y1 c)) (<= py (cuboid-y2 c)))
            (if (and (>= pz (cuboid-z1 c)) (<= pz (cuboid-z2 c)))
               'T 'nil) 'nil) 'nil))) 

(defun cumulative-point-power (cuboid-list point)
  (let ((powerval 'nil))
    (loop for c in cuboid-list
          :do (if (point-in-cuboid-p c point)
                  (setf powerval (cuboid-power c))))
    powerval))

(defun points-on-in-cube (cuboid-list c2)
  (loop for x from (cuboid-x1 c2) to (cuboid-x2 c2)
        :summing  (loop for y from (cuboid-y1 c2) to (cuboid-y2 c2)
                        :summing (loop for z from (cuboid-z1 c2) to (cuboid-z2 c2)
                                       :counting  (cumulative-point-power cuboid-list (list x y z)) into litcubes
                                       :finally (return litcubes)
                                       ) into ysum
                        :finally (return ysum)
                        ) into xsum
        :finally (return xsum))
  )
                             
(defmethod cuboid-intersection ((a cuboid) (b cuboid))
  (let ((max-x (max (cuboid-x1 a) (cuboid-x1 b)))
        (max-y (max (cuboid-y1 a) (cuboid-y1 b)))
        (max-z (max (cuboid-z1 a) (cuboid-z1 b)))
        (min-x (min (cuboid-x2 a) (cuboid-x2 b)))
        (min-y (min (cuboid-y2 a) (cuboid-y2 b)))
        (min-z (min (cuboid-z2 a) (cuboid-z2 b))))
    (if (and (>= (- min-x max-x) 0) (>= (- min-y max-y) 0) (>= (- min-z max-z) 0))
        (let ((c (make-cuboid-full max-x min-x max-y min-y max-z min-z 't)))
          c)
        'nil)))

(defmethod cube-volume ((c cuboid))
  (* (1+ (abs (- (cuboid-x2 c) (cuboid-x1 c))))
     (1+ (abs (- (cuboid-y2 c) (cuboid-y1 c))))
     (1+ (abs (- (cuboid-z2 c) (cuboid-z1 c))))))

(defun count-cubes (cuboid-list)
  (let ((cube-count 0)
        (counted-cubes 'nil))
    (loop for c in (reverse cuboid-list)
          :do (progn
                (if (cuboid-power c)
                    (let ((void-cubes 'nil))
                      (loop for inter in (mapcar (lambda (x) (cuboid-intersection c x)) counted-cubes)
                            :do (if inter
                                    (push inter void-cubes)))
                      (incf cube-count (cube-volume c))
                      (decf cube-count (count-cubes (reverse void-cubes)))))
                (push c counted-cubes ))
                )
      cube-count))

(defparameter *test-input* (read-input "inputs/input22.txt"))

(time (write (count-cubes *test-input*)))

